{"version":3,"sources":["lib/keyspace.js","components/Button.js","lib/broadcaster.js","components/Messenger.js","components/KeyspaceFlow.js","index.js","constants.js","utils.js","lib/ipfs.js"],"names":["require","ipfsStoreJSON","ipfsFetchJSONFromCID","keyspaceSignatureTextFn","ipfsKeyHash","key","t","struct","public","String","private","ipfsHash","refinement","s","length","generateKeyPair","signedSeed","signer","a","getAddress","address","openpgp","userIds","curve","passphrase","privateKeyArmored","publicKeyArmored","storeHash","signature","message","Promise","resolve","reject","all","fetch","SLS_PGP_URL","method","mode","body","JSON","stringify","then","response","ok","statusText","text","res","catch","err","KeySpace","seed","onRequestSignedSeed","onGeneratedSignedSeed","onRequestPGPKeyPair","onGeneratedPGPKeyPair","Error","this","bind","ipfsHashes","pgpKeys","initialized","init","signerAddress","toLowerCase","getHashByAddress","signerIPFSHash","signerPGPKey","console","log","signMessage","that","querystring","network","isPGPReady","createSignedSeed","keyPair","signatureText","fetchKeyByAddress","toAddress","toKey","readArmored","keys","privKeyObj","decrypt","fromText","publicKeys","privateKeys","ciphertext","data","encrypt","encryptedMessage","fromAddress","fromKey","plaintext","setUpPGP","signed","signedData","cleartext","verify","result","_","get","AuthButton","styled","Button","myTopic","PubSubBroadcaster","onReady","onNewMessage","node","IPFS","repo","EXPERIMENTAL","pubsub","relay","enabled","hop","active","config","Addresses","Swarm","on","_init","subscribe","handleMessageReceived","libp2p","handlePeerConnected","msg","messageData","toString","swarm","peers","multiaddr","protocol","connect","ipfsPeer","id","toB58String","topic","msgString","messageBuffer","Buffer","publish","makeIntroduction","type","from","nickname","requestIntroductions","makeMessage","to","MessageBody","Box","MessageContainer","MessageFrom","Anchor","Arrow","Text","Message","nicknames","direction","target","size","href","primary","label","background","Paragraph","Container","MessageBox","MessagesContainer","ControlsContainer","PeerCheck","CheckBox","Messenger","state","selectedPeers","messages","myMessages","newMessage","props","broadcaster","Broadcaster","sendMessage","window","setTimeout","setInterval","parse","addIntroduction","setState","decryptMessage","includes","newPeers","uniq","keySpace","decryptedMessage","newMessages","map","peerAddress","without","fill","flex","grow","Tabs","Tab","title","pad","overflow","prompt","Accordion","AccordionPanel","peerLabel","checked","onClick","setNickname","disabled","onChange","togglePeerInclusion","renderMessages","renderPeers","TextInput","placeholder","value","event","React","Component","MessengerHoldScreen","AccordianElement","content","App","stage","unsignedSeed","web3","eth","getAccounts","accounts","getSignedSeedForAddress","ethereum","enable","ethers","providers","Web3Provider","getSigner","walletAddress","storeSignedSeedForAddress","pgpKeyPairAccount","pgpKey","initializationError","split","item","formatErrorMessage","alignContent","border","width","myTheme","global","font","family","Grommet","full","theme","KeyspaceFlow","rootElement","document","getElementById","ReactDOM","render","module","exports","error","isObject","isString","obj","localStorage","setItem","signedSeedObj","getItem","parsedObj","ipfsInfura","host","port","ipfsAirSwap","pinJSONToIPFSPinata","JSONBody","url","axios","post","resp","IpfsHash","storeString","resolved","add","e","fetchIPFSContentFromCloudfare","cid","cat","undefined"],"mappings":"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","file":"static/js/main.82eef667.chunk.js","sourcesContent":["import _ from 'lodash'\nimport t from \"tcomb\"\nimport fetch from \"isomorphic-fetch\"\nimport querystring from \"querystring\"\nimport * as openpgp from 'openpgp'\nimport { SLS_PGP_URL } from \"../constants\"\n\nconst NETWORK = 4;\n\nconst { ipfsStoreJSON, ipfsFetchJSONFromCID } = require(\"./ipfs\");\n\nconst keyspaceDefaultSeedFn = address =>\n  `I'm generating my encryption keys for AirSwap ${address}`;\nconst keyspaceSignatureTextFn = ipfsKeyHash =>\n  `IPFS location of my Keyspace identity: ${ipfsKeyHash}`;\n\nconst key = t.struct({\n  public: t.String,\n  private: t.String\n});\n\nconst ipfsHash = t.refinement(t.String, s => s.length > 30, \"ipfsHash\");\n\nasync function generateKeyPair(signedSeed, signer) {\n  const address = await signer.getAddress();\n  const { privateKeyArmored, publicKeyArmored } = await openpgp.generateKey({\n    userIds: [{ address }],\n    curve: \"p256\", // ECC curve name, most widely supported\n    passphrase: signedSeed\n  });\n  return key({\n    private: privateKeyArmored,\n    public: publicKeyArmored\n  });\n}\n\nfunction storeHash({ address, signature, ipfsKeyHash, message }) {\n  return new Promise((resolve, reject) =>\n    Promise.all([\n      fetch(`${SLS_PGP_URL}/storeHash`, {\n        method: \"post\",\n        mode: \"cors\",\n        body: JSON.stringify({\n          address,\n          signature,\n          ipfsHash: ipfsKeyHash,\n          message\n        })\n      })\n    ])\n      .then(([response]) => {\n        if (!response.ok) {\n          reject(response.statusText);\n        }\n        return response.text();\n      })\n      .then(res => resolve(res))\n      .catch(err => {\n        reject(err);\n      })\n  );\n}\n\nclass KeySpace {\n  constructor({\n    signer,\n    signedSeed,\n    seed,\n    onRequestSignedSeed,\n    onGeneratedSignedSeed,\n    onRequestPGPKeyPair,\n    onGeneratedPGPKeyPair\n  }) {\n    if (!signer) {\n      throw new Error(\n        \"This keyspace implementation requires a valid ethers.js Signer\"\n      );\n    }\n    this.onRequestSignedSeed = onRequestSignedSeed.bind(this);\n    this.onGeneratedSignedSeed = onGeneratedSignedSeed.bind(this);\n    this.onRequestPGPKeyPair = onRequestPGPKeyPair.bind(this);\n    this.onGeneratedPGPKeyPair = onGeneratedPGPKeyPair.bind(this);\n    this.seed = seed;\n    this.signedSeed = signedSeed;\n    this.signer = signer;\n    this.ipfsHashes = {};\n    this.pgpKeys = {};\n    this.initialized = this.init();\n  }\n  async init() {\n    this.signerAddress = (await this.signer.getAddress()).toLowerCase();\n    this.seed = this.seed || keyspaceDefaultSeedFn(this.signerAddress);\n    try {\n      this.signerIPFSHash = await this.getHashByAddress(this.signerAddress);\n      this.signerPGPKey = await ipfsFetchJSONFromCID(this.signerIPFSHash);\n    } catch (e) {\n      console.log(\"ipfsHash for wallet not found\");\n      return true;\n    }\n    return true;\n  }\n  async createSignedSeed() {\n    return this.signer.signMessage(this.seed);\n  }\n  async getHashByAddress(address) {\n    const that = this;\n    return fetch(\n      `${SLS_PGP_URL}/getHashByAddress?${querystring.stringify({\n        address: address.toLowerCase(),\n        network: NETWORK\n      })}`,\n      {\n        method: \"get\",\n        mode: \"cors\"\n      }\n    ).then(async response => {\n      if (!response.ok) {\n        throw new Error(response.statusText);\n      }\n      const ipfsKeyHash = ipfsHash(await response.text());\n      that.ipfsHashes[address.toLowerCase()] = ipfsKeyHash;\n      return ipfsKeyHash;\n    });\n  }\n  async fetchKeyByAddress(address) {\n    if (this.pgpKeys[address.toLowerCase()]) {\n      return this.pgpKeys[address.toLowerCase()];\n    }\n    const ipfsKeyHash = await this.getHashByAddress(address.toLowerCase());\n    const key = await ipfsFetchJSONFromCID(ipfsKeyHash);\n    this.pgpKeys[address.toLowerCase()] = key;\n    return key;\n  }\n  async setUpPGP() {\n    await this.initialized;\n    if (this.isPGPReady()) {\n      this.onGeneratedSignedSeed(this.signedSeed)\n      this.onGeneratedPGPKeyPair(this.signerPGPKey)\n      return true;\n    }\n    if (!this.signedSeed) {\n      // generating signed seed\n      this.onRequestSignedSeed(this.seed);\n      try {\n        this.signedSeed = await this.createSignedSeed();\n        // generated signed seed\n        this.onGeneratedSignedSeed(this.signedSeed);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    } else {\n      this.onGeneratedSignedSeed(this.signedSeed)\n    }\n    if (!this.signerPGPKey) {\n      // generating key pair\n      this.onRequestPGPKeyPair(this.signerAddress);\n\n      let keyPair;\n      try {\n        keyPair = await generateKeyPair(this.signedSeed, this.signer);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      let ipfsKeyHash;\n      try {\n        ipfsKeyHash = ipfsHash(await ipfsStoreJSON(keyPair));\n      } catch (e) {\n        return Promise.reject('Could not connect to IPFS');\n      }\n\n      const signatureText = keyspaceSignatureTextFn(ipfsKeyHash);\n\n      let signature;\n      try {\n        signature = await this.signer.signMessage(signatureText);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      try {\n        await storeHash({\n          signature,\n          message: signatureText,\n          ipfsKeyHash,\n          address: this.signerAddress\n        });\n        // generated key pair\n        this.onGeneratedPGPKeyPair(keyPair);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      this.signerPGPKey = keyPair;\n      this.signerIPFSHash = ipfsKeyHash;\n    } else {\n      this.onGeneratedPGPKeyPair(this.signerPGPKey)\n    }\n    try {\n      await this.fetchKeyByAddress(this.signerAddress);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    return this.isPGPReady();\n  }\n  async encrypt(message, toAddress) {\n    const toKey = await this.fetchKeyByAddress(toAddress.toLowerCase());\n    const publicKeyArmored = toKey.public;\n    const [privKeyObj] = (await openpgp.key.readArmored(\n      this.signerPGPKey.private\n    )).keys;\n    await privKeyObj.decrypt(this.signedSeed);\n    return new Promise(async (resolve, reject) => {\n      openpgp\n        .encrypt({\n          message: openpgp.message.fromText(message), // input as Message object\n          publicKeys: (await openpgp.key.readArmored(publicKeyArmored)).keys, // for encryption\n          privateKeys: [privKeyObj] // for signing (optional)\n        })\n        .then(ciphertext => {\n          resolve(ciphertext.data);\n        })\n        .catch(reject);\n    });\n  }\n  async decrypt(encryptedMessage, fromAddress) {\n    const fromKey = await this.fetchKeyByAddress(fromAddress.toLowerCase());\n    const publicKeyArmored = fromKey.public;\n    const [privKeyObj] = (await openpgp.key.readArmored(\n      this.signerPGPKey.private\n    )).keys;\n    await privKeyObj.decrypt(this.signedSeed);\n    return new Promise(async (resolve, reject) => {\n      openpgp\n        .decrypt({\n          message: await openpgp.message.readArmored(encryptedMessage),\n          publicKeys: (await openpgp.key.readArmored(publicKeyArmored)).keys, // for verification (optional)\n          privateKeys: [privKeyObj]\n        })\n        .then(plaintext => {\n          resolve(plaintext.data);\n        })\n        .catch(reject);\n    });\n  }\n  async sign(text) {\n    await this.setUpPGP();\n    const privKeyObj = (await openpgp.key.readArmored(\n      this.signerPGPKey.private\n    )).keys[0];\n    await privKeyObj.decrypt(this.signedSeed);\n    const signedData = await openpgp\n      .sign({\n        message: openpgp.cleartext.fromText(text), // CleartextMessage or Message object\n        privateKeys: [privKeyObj] // for signing\n      })\n      .then(signed => signed.data);\n    return signedData;\n  }\n  async validate(cleartext, fromAddress) {\n    const fromKey = await this.fetchKeyByAddress(fromAddress.toLowerCase());\n    const publicKeyArmored = fromKey.public;\n    const result = await openpgp.verify({\n      message: await openpgp.cleartext.readArmored(cleartext), // parse armored message\n      publicKeys: (await openpgp.key.readArmored(publicKeyArmored)).keys // for verification\n    });\n    return _.get(result, \"signatures.0.valid\");\n  }\n\n  isPGPReady() {\n    return this.signedSeed && this.signerIPFSHash && this.signerPGPKey;\n  }\n}\n\nexport default KeySpace;\n","import styled from 'styled-components'\nimport { Button } from \"grommet\";\n\nconst AuthButton = styled(Button)`\n  //background: #2b71ff;\n  display: inline-block;\n  //color: white;\n  padding: 10px;\n  border-radius: 40px;\n  width: auto;\n  text-align: center;\n  width: 300px;\n`;\n\nexport default AuthButton\n","import IPFS from 'ipfs'\n\nconst myTopic = \"QmXG8yk8UJjMT6qtE2zSxzz3U7z5jSYRgVWLCUFqAVnByM\";\n\nclass PubSubBroadcaster {\n  constructor(onReady, onNewMessage) {\n    this.node = new IPFS({\n      // this is the indexDB location of the data we receive on the node\n      repo: \"./ipfs\",\n      // pubsub is required for sending pubsub messages\n      EXPERIMENTAL: { pubsub: true },\n      // allow messages to be relayed through our node\n      relay: { enabled: true, hop: { enabled: true, active: true } },\n      config: {\n        Addresses: {\n          // makes us discoverable to all nodes on the network\n          Swarm: [\n            \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\"\n          ]\n        }\n      }\n    });\n    this.node.on(\"ready\", this._init.bind(this));\n    this.onNewMessage = onNewMessage;\n    this.onReady = onReady\n  }\n\n  async _init() {\n    await this.node.pubsub.subscribe(\n      myTopic,\n      this.handleMessageReceived.bind(this)\n    );\n\n    this.node.libp2p.on(\"peer:connect\", this.handlePeerConnected.bind(this));\n\n    this.onReady();\n  }\n  handleMessageReceived(msg) {\n    const messageData = msg.data.toString();\n    this.onNewMessage(messageData);\n    console.log(\"msg received\", messageData);\n  }\n  async getIPFSSwarmPeers() {\n    return this.node.swarm.peers();\n  }\n  async connectToPeer(multiaddr, protocol = \"/p2p-circuit/ipfs/\") {\n    try {\n      await this.node.swarm.connect(`${protocol}${multiaddr}`);\n    } catch (e) {\n      debugger;\n      throw e;\n    }\n  }\n  handlePeerConnected(ipfsPeer) {\n    const ipfsId = ipfsPeer.id.toB58String();\n    // console.log(\"peer connected\", ipfsId);\n  }\n  async sendMessage(message, topic = myTopic) {\n    try {\n      const msgString = JSON.stringify(message);\n      const messageBuffer = IPFS.Buffer(msgString);\n      await this.node.pubsub.publish(topic, messageBuffer);\n    } catch (e) {\n      throw e;\n    }\n  }\n}\n\nexport default PubSubBroadcaster;\n","import _ from 'lodash'\nimport styled from 'styled-components'\nimport React from \"react\";\nimport { Heading, Text, Paragraph, TextInput, Tabs, Tab, Box, Anchor, Accordion, AccordionPanel, CheckBox } from \"grommet\";\nimport Broadcaster from \"../lib/broadcaster\";\nimport Button from './Button'\n// window.setInterval(() => {\n//   debugger;\n//   broadcaster.sendMessage(\"hello ya\");\n// }, 1000);\n\nconst makeIntroduction = ({ from, nickname }) => ({\n  type: 'introduction',\n  from,\n  nickname,\n})\n\nconst requestIntroductions = ({ from }) => ({\n  type: 'requestIntroductions',\n  from,\n})\n\nconst makeMessage = ({ message, from, to }) => ({\n  type: 'message',\n  from,\n  to,\n  message\n})\n\nconst MessageBody = styled(Box)`\n  border-radius: 15px;\n  padding: 0 15px;\n  overflow: hidden;\n`\n\nconst MessageContainer = styled(Box)`\n  margin-bottom: 10px;\n`\n\nconst MessageFrom = styled(Anchor)`\n  margin: 0 13px;\n`\nconst Arrow = styled(Text)`\n    position: relative;\n    top: -3px;\n`\n\nconst Message = ({ from, to, message, nicknames }) => <MessageContainer>\n  <Box direction=\"row\">\n  <MessageFrom target=\"_blank\" size=\"xsmall\" href={`https://rinkeby.etherscan.io/address/${from}`} primary label={nicknames[from] || from} />\n  {\n    to ?\n      <><Arrow>→</Arrow> <MessageFrom size=\"xsmall\" href={`https://rinkeby.etherscan.io/address/${to}`} primary label={nicknames[to] || to} /></> : null\n  }\n  </Box>\n  <MessageBody background=\"light-3\">\n    <Paragraph size=\"small\">\n      {message}\n    </Paragraph>\n  </MessageBody>\n</MessageContainer>\n\nconst Container = styled(Box)`\n  height: calc(100vh - 200px);\n  //position: absolute;\n`\n\nconst MessageBox = styled(Box)`\n  //height: calc(100vh - 182px)\n`\n\nconst MessagesContainer = styled(Box)`\n  margin-bottom: 300px;\n`\n\nconst ControlsContainer = styled(Box)`\n position: fixed;\n left: 0px;\n bottom: 0px;\n width: 100vw;\n background: white;\n padding: 5px 20px 20px 20px;\n`\n\nconst PeerCheck = styled(CheckBox)`\n margin-bottom: 5px;\n`\n\nclass Messenger extends React.Component {\n  state = {\n    peers: [],\n    selectedPeers: [],\n    messages: [],\n    myMessages: [],\n    newMessage: ``,\n    nicknames: {}\n  };\n  componentWillUnmount() {\n    debugger\n  }\n\n  componentDidMount() {\n    const { address } = this.props\n    this.broadcaster = new Broadcaster(\n      () => {\n        this.broadcaster.sendMessage(requestIntroductions({ from: address }))\n        window.setTimeout(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          5000\n        )\n\n        window.setTimeout(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          10000\n        )\n\n        window.setTimeout(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          15000\n        )\n\n        window.setInterval(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          60000\n        )\n      },\n      msg => {\n        const message = JSON.parse(msg)\n        if(message.type === 'requestIntroductions') {\n          this.broadcaster.sendMessage(makeIntroduction({ from: address, nickname: this.state.nicknames[address] }))\n          return\n        } else if(message.type === 'introduction') {\n          this.addIntroduction(message.from)\n          if(message.nickname) {\n            this.setState({\n              nicknames: {\n                [message.from]: message.nickname,\n                ...this.state.nicknames\n              }\n            })\n          }\n          return\n        } else if(message.type === 'message' && message.to === address) {\n          this.decryptMessage(message)\n        }\n\n      this.setState({ messages: [...this.state.messages, message] });\n    });\n  }\n  addIntroduction(address){\n    const { peers, selectedPeers } = this.state\n\n    if(!_.includes(peers, address.toLowerCase())) {\n      this.setState({\n        selectedPeers: [...selectedPeers, address.toLowerCase()],\n      })\n    }\n\n    const newPeers = _.uniq([...peers, address.toLowerCase()])\n    this.setState({ peers: newPeers })\n  }\n  async decryptMessage({ from, message }){\n    const { keySpace } = this.props\n    const { myMessages } = this.state\n    const decryptedMessage = await keySpace.decrypt(\n      message,\n      from.toLowerCase()\n    );\n    const newMessage = {\n      from,\n      message: decryptedMessage,\n    }\n    const newMessages = [...myMessages, newMessage]\n\n    this.setState({\n      myMessages: newMessages\n    })\n  }\n  sendMessage() {\n    const { selectedPeers, newMessage } = this.state\n    const { keySpace, address } = this.props\n    selectedPeers.map(async peerAddress => {\n      const encryptedMessage = await keySpace.encrypt(\n        newMessage,\n        peerAddress.toLowerCase()\n      );\n      this.broadcaster.sendMessage(makeMessage({\n        from: address,\n        to: peerAddress.toLowerCase(),\n        message: encryptedMessage\n      }))\n    })\n    this.setState({ newMessage: \"\" });\n  }\n  togglePeerInclusion(address) {\n    const { selectedPeers } = this.state\n    if(_.includes(selectedPeers, address)) {\n      this.setState({ selectedPeers: _.without(selectedPeers, address) })\n    } else {\n      this.setState({ selectedPeers: [...selectedPeers, address] })\n    }\n  }\n  renderMessages() {\n    const { messages, myMessages, nicknames } = this.state;\n\n    return <MessagesContainer fill=\"horizontal\" flex={{ grow: 1 }}>\n      <Tabs>\n      <Tab title=\"My Decrypted Chat\">\n        <MessageBox pad=\"medium\" overflow=\"scroll\">\n          {myMessages.map(({ from, message }) => <Message {...{ from, message }} nicknames={nicknames} />)}\n        </MessageBox>\n      </Tab>\n      <Tab title=\"Encrypted PubSub Stream\">\n        <MessageBox pad=\"medium\" overflow=\"scroll\">\n           {messages.map(({ from, to, message }) => <Message {...{ from, to, message }} nicknames={nicknames} />)}\n        </MessageBox>\n      </Tab>\n      {/*<Tab title=\"Discovery Protocol\">*/}\n      {/*  <Box pad=\"medium\" overflow=\"scroll\">*/}\n      {/*  </Box>*/}\n      {/*</Tab>*/}\n    </Tabs>\n    </MessagesContainer>\n  }\n  setNickname() {\n    const nickname = window.prompt('Please enter your nickname')\n    const { address } = this.props\n    this.broadcaster.sendMessage(makeIntroduction({ from: address, nickname }))\n  }\n  renderPeers(){\n    const { address } = this.props\n    const { peers, selectedPeers, nicknames } = this.state\n    const label = `Known Peers (${peers.length}) Selected Peers (${selectedPeers.length})`\n\n    return <Accordion>\n      <AccordionPanel label={label}>\n        <Box pad=\"small\" background=\"light-2\" overflow=\"scroll\">\n          {\n            peers.map(peerAddress => {\n              const peerLabel = nicknames[peerAddress] || peerAddress\n             return <PeerCheck\n               checked={_.includes(selectedPeers, peerAddress)}\n               label={peerAddress === address ? <Text>{peerLabel} <Anchor label=\"Set Nickname\" onClick={() => this.setNickname()} /></Text>  : <Text> {peerLabel} </Text>}\n               disabled={peerAddress === address}\n               onChange={() => this.togglePeerInclusion(peerAddress)}\n             />\n            })\n          }\n        </Box>\n      </AccordionPanel>\n    </Accordion>\n  }\n  render() {\n    const { newMessage, peers } = this.state;\n    return (\n      <Container>\n        {\n          this.renderMessages()\n        }\n        <ControlsContainer>\n          { this.renderPeers() }\n          <TextInput\n            placeholder=\"Send a message to the workshop's IPFS PubSub topic\"\n            value={newMessage}\n            onChange={event =>\n              this.setState({\n                newMessage: event.target.value\n              })\n            }\n\n          />\n          <br/>\n          <Button\n            label=\"Send Message\"\n            onClick={() => {\n              this.sendMessage();\n            }}\n          />\n        </ControlsContainer>\n      </Container>\n    );\n  }\n}\n\nexport default Messenger;\n","import React from \"react\";\nimport styled from \"styled-components\"\nimport KeySpace from \"../lib/keyspace\";\nimport { ethers } from \"ethers\";\nimport { Heading, Paragraph, Box, Accordion, AccordionPanel, Text } from \"grommet\";\nimport { formatErrorMessage, storeSignedSeedForAddress, getSignedSeedForAddress } from '../utils'\nimport Button from './Button'\nimport Messenger from './Messenger'\n\nconst getSigner = () => (new ethers.providers.Web3Provider(window.ethereum).getSigner());\n\nlet signer;\nlet keySpace;\n\nconst messageToSign = \"test meeeee\";\n\nconst MessengerHoldScreen = () => <Paragraph>Initialize Keyspace to use IPFS pubsub chat</Paragraph>\n\nconst AccordianElement = ({ content, label }) => <Box>\n    <Box overflow=\"scroll\">\n      <Paragraph size=\"small\">{label}</Paragraph>\n    </Box>\n    <Box pad=\"small\" background=\"light-2\" overflow=\"scroll\">\n      <Text size=\"xsmall\">\n        {\n          content\n        }\n      </Text>\n    </Box>\n</Box>\n\nconst Container = styled(Box)`\n  min-height: 100vh;\n`\nconst AuthButton = styled(Button)`\n  //background: #2b71ff;\n  display: inline-block;\n  //color: white;\n  padding: 10px;\n  border-radius: 40px;\n  width: auto;\n  text-align: center;\n`;\n\n\nclass App extends React.Component {\n  state = {\n    stage: \"initial\",\n    unsignedSeed: \"I'm generating my KeySpace PGP key encryption password\"\n  };\n  componentDidMount(){\n    window.web3.eth.getAccounts((err, accounts) => {\n      const [address] = accounts\n      if(address && getSignedSeedForAddress(address.toLowerCase())) {\n        this.init()\n      }\n    })\n  }\n  async init() {\n    await window.ethereum.enable();\n    this.setState({ stage: 'web3Enabled' })\n    signer = getSigner()\n    const walletAddress = (await signer.getAddress()).toLowerCase();\n    this.setState({ walletAddress })\n    const signedSeed = getSignedSeedForAddress(walletAddress);\n    keySpace = new KeySpace({\n      signer,\n      signedSeed,\n      seed: this.state.unsignedSeed,\n      onRequestSignedSeed: (unsignedSeed) => {\n        this.setState({\n          unsignedSeed,\n          stage: 'waitingForSeedSignature'\n        })\n      },\n      onGeneratedSignedSeed: (signedSeed) => {\n        storeSignedSeedForAddress({ signedSeed, address: walletAddress });\n        this.setState({\n          signedSeed,\n          stage: 'seedSigned'\n        })\n      },\n      onRequestPGPKeyPair: (pgpKeyPairAccount) => {\n        this.setState({\n          stage: 'waitingPGPPairSignature'\n        })\n      },\n      onGeneratedPGPKeyPair: (pgpKey) => {\n        this.setState({\n          stage: 'pgpPairGenerated',\n          pgpKey,\n        })\n      },\n    });\n    try {\n      await keySpace.setUpPGP();\n    } catch (initializationError) {\n      this.setState({\n        stage: 'keyspaceInitializationError',\n        initializationError\n      })\n      return\n    }\n  }\n  renderUnsignedSeed(){\n    const { unsignedSeed } = this.state\n    if(!unsignedSeed) {\n      return null\n    } else {\n      return <AccordianElement label=\"Unsigned Seed\" content={unsignedSeed} />\n    }\n  }\n  renderSignedSeed(){\n    const { signedSeed } = this.state\n    if(!signedSeed) {\n      return null\n    } else {\n      return <AccordianElement label=\"Signed Seed (PGP key encryption password)\" content={signedSeed} />\n    }\n  }\n  renderPGPKey(){\n    const { pgpKey } = this.state\n    if(!pgpKey) {\n      return null\n    } else {\n      return <>\n        <AccordianElement label=\"PGP Public Key\" content={ pgpKey.public\n          .split('\\\\r\\\\n')\n          .map((item, key) => {\n            return <span key={key}>{item}<br/></span>\n          })\n        } />\n        <AccordianElement label=\"PGP Private Key\" content={ pgpKey.private\n          .split('\\\\r\\\\n')\n          .map((item, key) => {\n            return <span key={key}>{item}<br/></span>\n          })\n        } />\n      </>\n    }\n  }\n  render() {\n    const { stage, initializationError, walletAddress } = this.state\n    let content\n    if(stage === 'initial') {\n      content = <AuthButton onClick={() => this.init()} label=\"Connect To Metamask\" />\n    }\n    if (stage === 'web3Enabled') {\n      content = <Text>Initializing KeySpace</Text>\n    }\n    if (stage === 'waitingForSeedSignature') {\n      content = <Text>Initializing KeySpace, Sign to create your seed</Text>\n    }\n    if (stage === 'waitingPGPPairSignature') {\n      content = <Text>Sign your generated PGP key pair to authenticate it</Text>\n    }\n    if (stage === 'pgpPairGenerated') {\n      content = <Text>KeySpace is ready</Text>\n    }\n    if(stage === 'keyspaceInitializationError') {\n      content = <Box>\n          <Text>{`Keyspace Initialization Error: ${formatErrorMessage(initializationError)}`}</Text>\n          <AuthButton onClick={() => this.init()} label=\"Retry\" />\n        </Box>\n    }\n    return <Box>\n        <Box pad=\"large\" direction=\"row\" alignContent=\"stretch\" border={{\n          \"color\": \"brand\",\n          \"size\": \"small\",\n          \"side\": \"bottom\"\n        }}>\n          <Box flex={{ grow: 1 }} direction=\"row\">\n            <Text size=\"xlarge\">KeySpace Devcon5 Demo</Text>\n          </Box>\n          <Box direction=\"row\">\n            {\n              content\n            }\n          </Box>\n        </Box>\n        <Container direction=\"row\" fill=\"horizontal\" pad=\"medium\">\n        <Box width=\"100%\">\n          {\n            stage === 'pgpPairGenerated' ?\n              <Messenger address={walletAddress} keySpace={keySpace} /> :\n              <MessengerHoldScreen />\n          }\n        </Box>\n        {/*<Box width=\"30%\">*/}\n        {/*{ content }*/}\n        {/*{ this.renderUnsignedSeed() }*/}\n        {/*{ this.renderSignedSeed() }*/}\n        {/*{ this.renderPGPKey() }*/}\n        {/*</Box>*/}\n      </Container>\n    </Box>;\n  }\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Grommet } from \"grommet\";\n// import Messenger from \"./components/Messenger\";\nimport KeyspaceFlow from \"./components/KeyspaceFlow\";\n// window.setInterval(() => {\n//   debugger;\n//   broadcaster.sendMessage(\"hello ya\");\n// }, 1000);\n\nconst myTheme = {\n  global: {\n    font: {\n      family: \"Lato\"\n    }\n  }\n};\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Grommet full={true} theme={myTheme}>\n        <KeyspaceFlow />\n      </Grommet>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n","const SLS_PGP_URL = \"https://pgp.development.airswap.io\";\n\nmodule.exports = { SLS_PGP_URL }\n","const _ = require('lodash')\n\nfunction formatErrorMessage(error) {\n  if (_.isObject(error) && error.message) {\n    return error.message.split('\\n')[0] // sometimes metamask returns stacktraces and this removes them\n  } else if (_.isString(error)) {\n    return error\n  }\n  return ''\n}\n\nfunction storeSignedSeedForAddress({ address, signedSeed }) {\n  const obj = JSON.stringify({ address, signedSeed })\n  localStorage.setItem('signedSeed', obj)\n}\n\nfunction getSignedSeedForAddress(address) {\n  const signedSeedObj = localStorage.getItem('signedSeed')\n  if(signedSeedObj) {\n    const parsedObj = JSON.parse(signedSeedObj)\n    if(parsedObj.address === address) {\n      return parsedObj.signedSeed\n    }\n  }\n  return undefined\n}\n\nmodule.exports = { formatErrorMessage, storeSignedSeedForAddress, getSignedSeedForAddress }\n","import _ from \"lodash\"\nimport axios from \"axios\"\nimport IPFS from \"ipfs-mini\"\nimport { SLS_PGP_URL } from \"../constants\"\n\n\nconst ipfsInfura = new IPFS({\n  host: \"ipfs.infura.io\",\n  port: 5001,\n  protocol: \"https\"\n});\n\nconst ipfsAirSwap = new IPFS({\n  host: \"ipfs.airswap.io\",\n  port: 443,\n  protocol: \"https\"\n});\n\nconst pinJSONToIPFSPinata = JSONBody => {\n  const url = `${SLS_PGP_URL}/storePinata`;\n  return axios.post(url, JSONBody).then(resp => resp.data.IpfsHash);\n};\n\nexport async function ipfsStoreJSON(obj) {\n  const storeString = _.isString(obj)\n    ? JSON.stringify(JSON.parse(obj))\n    : JSON.stringify(obj);\n\n  return new Promise((resolve, reject) => {\n    // this \"resolved\" syntax is required since there isn't a Promise.none()\n    let resolved = 0;\n    ipfsAirSwap\n      .add(storeString)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 2) {\n          reject(e);\n        }\n      });\n    ipfsInfura\n      .add(storeString)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 2) {\n          reject(e);\n        }\n      });\n\n    pinJSONToIPFSPinata(JSON.parse(storeString)); // pinata will always take the longest to resolve since they don't support reads\n  });\n}\n\nconst fetchIPFSContentFromCloudfare = cid =>\n  axios\n    .get(`https://cloudflare-ipfs.com/ipfs/${cid}`)\n    .then(resp => JSON.stringify(resp.data));\n\nexport async function ipfsFetchJSONFromCID(cid) {\n  const content = await new Promise((resolve, reject) => {\n    if (!cid) {\n      resolve(undefined);\n      return;\n    }\n    // this \"resolved\" syntax is required since there isn't a Promise.none()\n    let resolved = 0;\n    ipfsAirSwap\n      .cat(cid)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 3) {\n          reject(e);\n        }\n      });\n    ipfsInfura\n      .cat(cid)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 3) {\n          reject(e);\n        }\n      });\n\n    fetchIPFSContentFromCloudfare(cid)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 3) {\n          reject(e);\n        }\n      });\n  });\n  return JSON.parse(content);\n}\n"],"sourceRoot":""}