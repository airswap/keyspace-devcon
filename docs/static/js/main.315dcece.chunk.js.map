{"version":3,"sources":["lib/keyspace.js","components/Button.js","lib/broadcaster.js","components/Messenger.js","components/KeyspaceFlow.js","index.js","constants.js","utils.js","lib/ipfs.js"],"names":["require","ipfsStoreJSON","ipfsFetchJSONFromCID","keyspaceSignatureTextFn","ipfsKeyHash","key","t","struct","public","String","private","ipfsHash","refinement","s","length","generateKeyPair","signedSeed","signer","a","getAddress","address","openpgp","userIds","curve","passphrase","privateKeyArmored","publicKeyArmored","storeHash","signature","message","Promise","resolve","reject","all","fetch","SLS_PGP_URL","method","mode","body","JSON","stringify","then","response","ok","statusText","text","res","catch","err","KeySpace","seed","onRequestSignedSeed","onGeneratedSignedSeed","onRequestPGPKeyPair","onGeneratedPGPKeyPair","Error","this","bind","ipfsHashes","pgpKeys","initialized","init","signerAddress","toLowerCase","getHashByAddress","signerIPFSHash","signerPGPKey","console","log","signMessage","that","querystring","network","isPGPReady","createSignedSeed","keyPair","signatureText","fetchKeyByAddress","toAddress","toKey","readArmored","keys","privKeyObj","decrypt","fromText","publicKeys","privateKeys","ciphertext","data","encrypt","encryptedMessage","fromAddress","fromKey","plaintext","setUpPGP","signed","signedData","cleartext","verify","result","_","get","AuthButton","styled","Button","myTopic","PubSubBroadcaster","onReady","onNewMessage","node","IPFS","repo","EXPERIMENTAL","pubsub","relay","enabled","hop","active","config","Addresses","Swarm","on","_init","subscribe","handleMessageReceived","libp2p","handlePeerConnected","msg","messageData","toString","swarm","peers","multiaddr","protocol","connect","ipfsPeer","id","toB58String","topic","msgString","messageBuffer","Buffer","publish","makeIntroduction","type","from","nickname","requestIntroductions","makeMessage","to","MessageBody","Box","MessageContainer","MessageFrom","Anchor","Arrow","Text","Message","nicknames","direction","target","size","href","primary","label","background","Paragraph","Container","MessageBox","MessagesContainer","ControlsContainer","PeerCheck","CheckBox","Messenger","state","selectedPeers","messages","myMessages","newMessage","discoveryMessages","props","broadcaster","Broadcaster","sendMessage","window","setTimeout","setInterval","parse","setState","addIntroduction","decryptMessage","includes","newPeers","uniq","keySpace","decryptedMessage","newMessages","map","peerAddress","without","fill","flex","grow","Tabs","Tab","title","mobile","pad","overflow","reverse","slice","prompt","Accordion","AccordionPanel","peerLabel","checked","onClick","setNickname","disabled","onChange","togglePeerInclusion","renderMessages","renderPeers","TextInput","placeholder","value","event","onKeyDown","e","React","Component","getSigner","ethers","providers","Web3Provider","ethereum","AccordianElement","content","AboutButton","HeaderRightBox","App","stage","unsignedSeed","web3","eth","getAccounts","accounts","getSignedSeedForAddress","enable","initializationError","Wallet","createRandom","walletAddress","storeSignedSeedForAddress","pgpKeyPairAccount","pgpKey","split","item","headerContent","margin","DropButton","dropAlign","top","right","dropContent","border","renderUnsignedSeed","renderSignedSeed","renderPGPKey","formatErrorMessage","alignContent","open","width","align","myTheme","global","font","family","Grommet","full","theme","KeyspaceFlow","rootElement","document","getElementById","ReactDOM","render","module","exports","error","isObject","isString","obj","localStorage","setItem","signedSeedObj","getItem","parsedObj","ipfsInfura","host","port","ipfsAirSwap","pinJSONToIPFSPinata","JSONBody","url","axios","post","resp","IpfsHash","storeString","resolved","add","fetchIPFSContentFromCloudfare","cid","cat","undefined"],"mappings":"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","file":"static/js/main.315dcece.chunk.js","sourcesContent":["import _ from 'lodash'\nimport t from \"tcomb\"\nimport fetch from \"isomorphic-fetch\"\nimport querystring from \"querystring\"\nimport * as openpgp from 'openpgp'\nimport { SLS_PGP_URL } from \"../constants\"\n\nconst NETWORK = 4;\n\nconst { ipfsStoreJSON, ipfsFetchJSONFromCID } = require(\"./ipfs\");\n\nconst keyspaceDefaultSeedFn = address =>\n  `I'm generating my encryption keys for AirSwap ${address}`;\nconst keyspaceSignatureTextFn = ipfsKeyHash =>\n  `IPFS location of my Keyspace identity: ${ipfsKeyHash}`;\n\nconst key = t.struct({\n  public: t.String,\n  private: t.String\n});\n\nconst ipfsHash = t.refinement(t.String, s => s.length > 30, \"ipfsHash\");\n\nasync function generateKeyPair(signedSeed, signer) {\n  const address = await signer.getAddress();\n  const { privateKeyArmored, publicKeyArmored } = await openpgp.generateKey({\n    userIds: [{ address }],\n    curve: \"p256\", // ECC curve name, most widely supported\n    passphrase: signedSeed\n  });\n  return key({\n    private: privateKeyArmored,\n    public: publicKeyArmored\n  });\n}\n\nfunction storeHash({ address, signature, ipfsKeyHash, message }) {\n  return new Promise((resolve, reject) =>\n    Promise.all([\n      fetch(`${SLS_PGP_URL}/storeHash`, {\n        method: \"post\",\n        mode: \"cors\",\n        body: JSON.stringify({\n          address,\n          signature,\n          ipfsHash: ipfsKeyHash,\n          message\n        })\n      })\n    ])\n      .then(([response]) => {\n        if (!response.ok) {\n          reject(response.statusText);\n        }\n        return response.text();\n      })\n      .then(res => resolve(res))\n      .catch(err => {\n        reject(err);\n      })\n  );\n}\n\nclass KeySpace {\n  constructor({\n    signer,\n    signedSeed,\n    seed,\n    onRequestSignedSeed,\n    onGeneratedSignedSeed,\n    onRequestPGPKeyPair,\n    onGeneratedPGPKeyPair\n  }) {\n    if (!signer) {\n      throw new Error(\n        \"This keyspace implementation requires a valid ethers.js Signer\"\n      );\n    }\n    this.onRequestSignedSeed = onRequestSignedSeed.bind(this);\n    this.onGeneratedSignedSeed = onGeneratedSignedSeed.bind(this);\n    this.onRequestPGPKeyPair = onRequestPGPKeyPair.bind(this);\n    this.onGeneratedPGPKeyPair = onGeneratedPGPKeyPair.bind(this);\n    this.seed = seed;\n    this.signedSeed = signedSeed;\n    this.signer = signer;\n    this.ipfsHashes = {};\n    this.pgpKeys = {};\n    this.initialized = this.init();\n  }\n  async init() {\n    this.signerAddress = (await this.signer.getAddress()).toLowerCase();\n    this.seed = this.seed || keyspaceDefaultSeedFn(this.signerAddress);\n    try {\n      this.signerIPFSHash = await this.getHashByAddress(this.signerAddress);\n      this.signerPGPKey = await ipfsFetchJSONFromCID(this.signerIPFSHash);\n    } catch (e) {\n      console.log(\"ipfsHash for wallet not found\");\n      return true;\n    }\n    return true;\n  }\n  async createSignedSeed() {\n    return this.signer.signMessage(this.seed);\n  }\n  async getHashByAddress(address) {\n    const that = this;\n    return fetch(\n      `${SLS_PGP_URL}/getHashByAddress?${querystring.stringify({\n        address: address.toLowerCase(),\n        network: NETWORK\n      })}`,\n      {\n        method: \"get\",\n        mode: \"cors\"\n      }\n    ).then(async response => {\n      if (!response.ok) {\n        throw new Error(response.statusText);\n      }\n      const ipfsKeyHash = ipfsHash(await response.text());\n      that.ipfsHashes[address.toLowerCase()] = ipfsKeyHash;\n      return ipfsKeyHash;\n    });\n  }\n  async fetchKeyByAddress(address) {\n    if (this.pgpKeys[address.toLowerCase()]) {\n      return this.pgpKeys[address.toLowerCase()];\n    }\n    const ipfsKeyHash = await this.getHashByAddress(address.toLowerCase());\n    const key = await ipfsFetchJSONFromCID(ipfsKeyHash);\n    this.pgpKeys[address.toLowerCase()] = key;\n    return key;\n  }\n  async setUpPGP() {\n    await this.initialized;\n    if (this.isPGPReady()) {\n      this.onGeneratedSignedSeed(this.signedSeed)\n      this.onGeneratedPGPKeyPair(this.signerPGPKey)\n      return true;\n    }\n    if (!this.signedSeed) {\n      // generating signed seed\n      this.onRequestSignedSeed(this.seed);\n      try {\n        this.signedSeed = await this.createSignedSeed();\n        // generated signed seed\n        this.onGeneratedSignedSeed(this.signedSeed);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    } else {\n      this.onGeneratedSignedSeed(this.signedSeed)\n    }\n    if (!this.signerPGPKey) {\n      // generating key pair\n      this.onRequestPGPKeyPair(this.signerAddress);\n\n      let keyPair;\n      try {\n        keyPair = await generateKeyPair(this.signedSeed, this.signer);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      let ipfsKeyHash;\n      try {\n        ipfsKeyHash = ipfsHash(await ipfsStoreJSON(keyPair));\n      } catch (e) {\n        return Promise.reject('Could not connect to IPFS');\n      }\n\n      const signatureText = keyspaceSignatureTextFn(ipfsKeyHash);\n\n      let signature;\n      try {\n        signature = await this.signer.signMessage(signatureText);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      try {\n        await storeHash({\n          signature,\n          message: signatureText,\n          ipfsKeyHash,\n          address: this.signerAddress\n        });\n        // generated key pair\n        this.onGeneratedPGPKeyPair(keyPair);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      this.signerPGPKey = keyPair;\n      this.signerIPFSHash = ipfsKeyHash;\n    } else {\n      this.onGeneratedPGPKeyPair(this.signerPGPKey)\n    }\n    try {\n      await this.fetchKeyByAddress(this.signerAddress);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    return this.isPGPReady();\n  }\n  async encrypt(message, toAddress) {\n    const toKey = await this.fetchKeyByAddress(toAddress.toLowerCase());\n    const publicKeyArmored = toKey.public;\n    const [privKeyObj] = (await openpgp.key.readArmored(\n      this.signerPGPKey.private\n    )).keys;\n    await privKeyObj.decrypt(this.signedSeed);\n    return new Promise(async (resolve, reject) => {\n      openpgp\n        .encrypt({\n          message: openpgp.message.fromText(message), // input as Message object\n          publicKeys: (await openpgp.key.readArmored(publicKeyArmored)).keys, // for encryption\n          privateKeys: [privKeyObj] // for signing (optional)\n        })\n        .then(ciphertext => {\n          resolve(ciphertext.data);\n        })\n        .catch(reject);\n    });\n  }\n  async decrypt(encryptedMessage, fromAddress) {\n    const fromKey = await this.fetchKeyByAddress(fromAddress.toLowerCase());\n    const publicKeyArmored = fromKey.public;\n    const [privKeyObj] = (await openpgp.key.readArmored(\n      this.signerPGPKey.private\n    )).keys;\n    await privKeyObj.decrypt(this.signedSeed);\n    return new Promise(async (resolve, reject) => {\n      openpgp\n        .decrypt({\n          message: await openpgp.message.readArmored(encryptedMessage),\n          publicKeys: (await openpgp.key.readArmored(publicKeyArmored)).keys, // for verification (optional)\n          privateKeys: [privKeyObj]\n        })\n        .then(plaintext => {\n          resolve(plaintext.data);\n        })\n        .catch(reject);\n    });\n  }\n  async sign(text) {\n    await this.setUpPGP();\n    const privKeyObj = (await openpgp.key.readArmored(\n      this.signerPGPKey.private\n    )).keys[0];\n    await privKeyObj.decrypt(this.signedSeed);\n    const signedData = await openpgp\n      .sign({\n        message: openpgp.cleartext.fromText(text), // CleartextMessage or Message object\n        privateKeys: [privKeyObj] // for signing\n      })\n      .then(signed => signed.data);\n    return signedData;\n  }\n  async validate(cleartext, fromAddress) {\n    const fromKey = await this.fetchKeyByAddress(fromAddress.toLowerCase());\n    const publicKeyArmored = fromKey.public;\n    const result = await openpgp.verify({\n      message: await openpgp.cleartext.readArmored(cleartext), // parse armored message\n      publicKeys: (await openpgp.key.readArmored(publicKeyArmored)).keys // for verification\n    });\n    return _.get(result, \"signatures.0.valid\");\n  }\n\n  isPGPReady() {\n    return this.signedSeed && this.signerIPFSHash && this.signerPGPKey;\n  }\n}\n\nexport default KeySpace;\n","import styled from 'styled-components'\nimport { Button } from \"grommet\";\n\nconst AuthButton = styled(Button)`\n  //background: #2b71ff;\n  display: inline-block;\n  //color: white;\n  padding: 10px;\n  border-radius: 40px;\n  width: auto;\n  text-align: center;\n  width: 300px;\n`;\n\nexport default AuthButton\n","import IPFS from 'ipfs'\n\nconst myTopic = \"QmXG8yk8UJjMT6qtE2zSxzz3U7z5jSYRgVWLCUFqAVnByM\";\n\nclass PubSubBroadcaster {\n  constructor(onReady, onNewMessage) {\n    this.node = new IPFS({\n      // this is the indexDB location of the data we receive on the node\n      repo: \"./ipfs\",\n      // pubsub is required for sending pubsub messages\n      EXPERIMENTAL: { pubsub: true },\n      // allow messages to be relayed through our node\n      relay: { enabled: true, hop: { enabled: true, active: true } },\n      config: {\n        Addresses: {\n          // makes us discoverable to all nodes on the network\n          Swarm: [\n            \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\"\n          ]\n        }\n      }\n    });\n    this.node.on(\"ready\", this._init.bind(this));\n    this.onNewMessage = onNewMessage;\n    this.onReady = onReady\n  }\n\n  async _init() {\n    await this.node.pubsub.subscribe(\n      myTopic,\n      this.handleMessageReceived.bind(this)\n    );\n\n    this.node.libp2p.on(\"peer:connect\", this.handlePeerConnected.bind(this));\n\n    this.onReady();\n  }\n  handleMessageReceived(msg) {\n    const messageData = msg.data.toString();\n    this.onNewMessage(messageData);\n    console.log(\"msg received\", messageData);\n  }\n  async getIPFSSwarmPeers() {\n    return this.node.swarm.peers();\n  }\n  async connectToPeer(multiaddr, protocol = \"/p2p-circuit/ipfs/\") {\n    try {\n      await this.node.swarm.connect(`${protocol}${multiaddr}`);\n    } catch (e) {\n      debugger;\n      throw e;\n    }\n  }\n  handlePeerConnected(ipfsPeer) {\n    const ipfsId = ipfsPeer.id.toB58String();\n    // console.log(\"peer connected\", ipfsId);\n  }\n  async sendMessage(message, topic = myTopic) {\n    try {\n      const msgString = JSON.stringify(message);\n      const messageBuffer = IPFS.Buffer(msgString);\n      await this.node.pubsub.publish(topic, messageBuffer);\n    } catch (e) {\n      throw e;\n    }\n  }\n}\n\nexport default PubSubBroadcaster;\n","import _ from 'lodash'\nimport styled from 'styled-components'\nimport React from \"react\";\nimport mobile from 'is-mobile'\nimport { Heading, Text, Paragraph, TextInput, Tabs, Tab, Box, Anchor, Accordion, AccordionPanel, CheckBox } from \"grommet\";\nimport Broadcaster from \"../lib/broadcaster\";\nimport Button from './Button'\n// window.setInterval(() => {\n//   debugger;\n//   broadcaster.sendMessage(\"hello ya\");\n// }, 1000);\n\nconst makeIntroduction = ({ from, nickname }) => ({\n  type: 'introduction',\n  from,\n  nickname,\n})\n\nconst requestIntroductions = ({ from }) => ({\n  type: 'requestIntroductions',\n  from,\n})\n\nconst makeMessage = ({ message, from, to }) => ({\n  type: 'message',\n  from,\n  to,\n  message\n})\n\nconst MessageBody = styled(Box)`\n  border-radius: 15px;\n  padding: 0 15px;\n  overflow: hidden;\n`\n\nconst MessageContainer = styled(Box)`\n  margin-bottom: 10px;\n`\n\nconst MessageFrom = styled(Anchor)`\n  margin: 0 13px;\n`\nconst Arrow = styled(Text)`\n    position: relative;\n    top: -3px;\n`\n\nconst Message = ({ from, to, message, nicknames }) => <MessageContainer>\n  <Box direction=\"row\">\n  <MessageFrom target=\"_blank\" size=\"xsmall\" href={`https://rinkeby.etherscan.io/address/${from}`} primary label={nicknames[from] || from} />\n  {\n    to ?\n      <><Arrow>â†’</Arrow> <MessageFrom size=\"xsmall\" href={`https://rinkeby.etherscan.io/address/${to}`} primary label={nicknames[to] || to} /></> : null\n  }\n  </Box>\n  <MessageBody background=\"light-3\">\n    <Paragraph size=\"small\">\n      {message}\n    </Paragraph>\n  </MessageBody>\n</MessageContainer>\n\nconst Container = styled(Box)`\n  height: calc(100vh - 200px);\n  //position: absolute;\n`\n\nconst MessageBox = styled(Box)`\n  //height: calc(100vh - 182px)\n`\n\nconst MessagesContainer = styled(Box)`\n  margin-bottom: 300px;\n`\n\nconst ControlsContainer = styled(Box)`\n position: fixed;\n left: 0px;\n bottom: 0px;\n width: 100vw;\n background: white;\n padding: 5px 20px 20px 20px;\n`\n\nconst PeerCheck = styled(CheckBox)`\n margin-bottom: 5px;\n`\n\nclass Messenger extends React.Component {\n  state = {\n    peers: [],\n    selectedPeers: [],\n    messages: [],\n    myMessages: [],\n    newMessage: ``,\n    nicknames: {},\n    discoveryMessages: []\n  };\n  componentWillUnmount() {\n    debugger\n  }\n\n  componentDidMount() {\n    const { address } = this.props\n    this.broadcaster = new Broadcaster(\n      () => {\n        this.broadcaster.sendMessage(requestIntroductions({ from: address }))\n        window.setTimeout(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          5000\n        )\n\n        window.setTimeout(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          10000\n        )\n\n        window.setTimeout(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          15000\n        )\n\n        window.setInterval(\n          () => this.broadcaster.sendMessage(requestIntroductions({ from: address })),\n          60000\n        )\n      },\n      msg => {\n        const message = JSON.parse(msg)\n        if(message.type === 'requestIntroductions') {\n          this.broadcaster.sendMessage(makeIntroduction({ from: address, nickname: this.state.nicknames[address] }))\n          this.setState({ discoveryMessages: [...this.state.discoveryMessages, message] });\n          return\n        } else if(message.type === 'introduction') {\n          this.addIntroduction(message.from)\n          if(message.nickname) {\n            this.setState({\n              nicknames: {\n                [message.from]: message.nickname,\n                ...this.state.nicknames\n              }\n            })\n          }\n          this.setState({ discoveryMessages: [...this.state.discoveryMessages, message] });\n          return\n        } else if(message.type === 'message' && message.to === address) {\n          this.decryptMessage(message)\n        }\n\n      this.setState({ messages: [...this.state.messages, message] });\n    });\n  }\n  addIntroduction(address){\n    const { peers, selectedPeers } = this.state\n\n    if(!_.includes(peers, address.toLowerCase())) {\n      this.setState({\n        selectedPeers: [...selectedPeers, address.toLowerCase()],\n      })\n    }\n\n    const newPeers = _.uniq([...peers, address.toLowerCase()])\n    this.setState({ peers: newPeers })\n  }\n  async decryptMessage({ from, message }){\n    const { keySpace } = this.props\n    const { myMessages } = this.state\n    const decryptedMessage = await keySpace.decrypt(\n      message,\n      from.toLowerCase()\n    );\n    const newMessage = {\n      from,\n      message: decryptedMessage,\n    }\n    const newMessages = [...myMessages, newMessage]\n\n    this.setState({\n      myMessages: newMessages\n    })\n  }\n  sendMessage() {\n    const { selectedPeers, newMessage } = this.state\n    const { keySpace, address } = this.props\n    selectedPeers.map(async peerAddress => {\n      const encryptedMessage = await keySpace.encrypt(\n        newMessage,\n        peerAddress.toLowerCase()\n      );\n      this.broadcaster.sendMessage(makeMessage({\n        from: address,\n        to: peerAddress.toLowerCase(),\n        message: encryptedMessage\n      }))\n    })\n    this.setState({ newMessage: \"\" });\n  }\n  togglePeerInclusion(address) {\n    const { selectedPeers } = this.state\n    if(_.includes(selectedPeers, address)) {\n      this.setState({ selectedPeers: _.without(selectedPeers, address) })\n    } else {\n      this.setState({ selectedPeers: [...selectedPeers, address] })\n    }\n  }\n  renderMessages() {\n    const { messages, myMessages, discoveryMessages, nicknames } = this.state;\n\n    return <MessagesContainer fill=\"horizontal\" flex={{ grow: 1 }}>\n      <Tabs>\n      <Tab title={ mobile() ? `Chat (${myMessages.length})` : `My Decrypted Chat (${myMessages.length})` }>\n        <MessageBox pad=\"medium\" overflow=\"scroll\">\n          {myMessages.map(({ from, message }) => <Message {...{ from, message }} nicknames={nicknames} />)}\n        </MessageBox>\n      </Tab>\n      <Tab title={ mobile() ? `PubSub (${messages.length})` : `Encrypted PubSub Stream (${messages.length})` }>\n        <MessageBox pad=\"medium\" overflow=\"scroll\">\n           {messages.map(({ from, to, message }) => <Message {...{ from, to, message }} nicknames={nicknames} />)}\n        </MessageBox>\n      </Tab>\n      <Tab title={ mobile() ? `Peer (${discoveryMessages.length})` : `Peer Discovery Protocol (${discoveryMessages.length})` }>\n        <MessageBox pad=\"medium\" overflow=\"scroll\">\n          {[...discoveryMessages].reverse().slice(0, 20).reverse().map(({ from, to, type, nickname }) => <Message {...{ from, to, message: `${type}${ nickname ? `, nickname: ${nickname}` : ''}` }} nicknames={nicknames} />)}\n        </MessageBox>\n      </Tab>\n    </Tabs>\n    </MessagesContainer>\n  }\n  setNickname() {\n    const nickname = window.prompt('Please enter your nickname')\n    const { address } = this.props\n    this.broadcaster.sendMessage(makeIntroduction({ from: address, nickname }))\n  }\n  renderPeers(){\n    const { address } = this.props\n    const { peers, selectedPeers, nicknames } = this.state\n    const label = mobile() ? `Peers (${peers.length}) Selected (${selectedPeers.length})` :\n      `Known Peers (${peers.length}) Selected Peers (${selectedPeers.length})`\n\n    return <Accordion>\n      <AccordionPanel label={label}>\n        <Box pad=\"small\" background=\"light-2\" overflow=\"scroll\">\n          {\n            peers.map(peerAddress => {\n              const peerLabel = nicknames[peerAddress] || peerAddress\n             return <PeerCheck\n               checked={_.includes(selectedPeers, peerAddress)}\n               label={peerAddress === address ? <Text>{peerLabel} <Anchor label=\"Set Nickname\" onClick={() => this.setNickname()} /></Text>  : <Text> {peerLabel} </Text>}\n               disabled={peerAddress === address}\n               onChange={() => this.togglePeerInclusion(peerAddress)}\n             />\n            })\n          }\n        </Box>\n      </AccordionPanel>\n    </Accordion>\n  }\n  render() {\n    const { newMessage, peers } = this.state;\n    return (\n      <Container>\n        {\n          this.renderMessages()\n        }\n        <ControlsContainer>\n          { this.renderPeers() }\n          <TextInput\n            placeholder=\"Send a message to the workshop's IPFS PubSub topic\"\n            value={newMessage}\n            onChange={event =>\n              this.setState({\n                newMessage: event.target.value\n              })\n            }\n            onKeyDown={(e) => {\n              if (e.key === 'Enter') {\n                this.sendMessage();\n              }\n            }}\n\n          />\n          <br/>\n          <Button\n            label=\"Send Message\"\n            onClick={() => {\n              this.sendMessage();\n            }}\n          />\n        </ControlsContainer>\n      </Container>\n    );\n  }\n}\n\nexport default Messenger;\n","import React from \"react\";\nimport styled from \"styled-components\"\nimport KeySpace from \"../lib/keyspace\";\nimport { ethers } from \"ethers\";\nimport { Heading, Paragraph, Box, Accordion, AccordionPanel, Text, DropButton } from \"grommet\";\nimport { formatErrorMessage, storeSignedSeedForAddress, getSignedSeedForAddress } from '../utils'\nimport Button from './Button'\nimport Messenger from './Messenger'\nimport mobile from 'is-mobile'\n\n\nconst getSigner = () => (new ethers.providers.Web3Provider(window.ethereum).getSigner());\n\nlet signer;\nlet keySpace;\n\nconst messageToSign = \"test meeeee\";\n\nconst AccordianElement = ({ content, label }) => <Box>\n    <Box overflow=\"scroll\">\n      <Paragraph size=\"small\">{label}</Paragraph>\n    </Box>\n    <Box pad=\"small\" background=\"light-2\" overflow=\"scroll\">\n      <Text size=\"xsmall\">\n        {\n          content\n        }\n      </Text>\n    </Box>\n</Box>\n\nconst Container = styled(Box)`\n  min-height: 100vh;\n`\nconst AuthButton = styled(Button)`\n  //background: #2b71ff;\n  display: inline-block;\n  //color: white;\n  padding: 10px;\n  border-radius: 40px;\n  width: auto;\n  text-align: center;\n`;\n\nconst AboutButton = styled(AuthButton)`\n  position: absolute; \n  right: 0;\n  padding: 4px 10px;\n  top: ${ mobile() ? '-15px' : '-12px'};\n`\n\nconst HeaderRightBox = styled(Box)`\nposition: relative;\n`\n\nclass App extends React.Component {\n  state = {\n    stage: \"initial\",\n    unsignedSeed: \"I'm generating my KeySpace PGP key encryption password\"\n  };\n  componentDidMount(){\n    window.web3 && window.web3.eth.getAccounts((err, accounts) => {\n      const [address] = accounts\n      if(address && getSignedSeedForAddress(address.toLowerCase())) {\n        this.init()\n      }\n    })\n  }\n  async init(type = 'metamask') {\n\n    if(type === 'metamask') {\n      try {\n        await window.ethereum.enable();\n      } catch (e) {\n        this.setState({\n          stage: 'keyspaceInitializationError',\n          initializationError: 'Web3 not detected'\n        })\n        return\n      }\n      this.setState({stage: 'web3Enabled'})\n      signer = getSigner()\n    } else if(type === 'newWallet') {\n      this.setState({stage: 'web3Enabled'})\n      signer = ethers.Wallet.createRandom()\n    }\n    const walletAddress = (await signer.getAddress()).toLowerCase();\n    this.setState({ walletAddress })\n    const signedSeed = getSignedSeedForAddress(walletAddress);\n    keySpace = new KeySpace({\n      signer,\n      signedSeed,\n      seed: this.state.unsignedSeed,\n      onRequestSignedSeed: (unsignedSeed) => {\n        this.setState({\n          unsignedSeed,\n          stage: 'waitingForSeedSignature'\n        })\n      },\n      onGeneratedSignedSeed: (signedSeed) => {\n        storeSignedSeedForAddress({ signedSeed, address: walletAddress });\n        this.setState({\n          signedSeed,\n          stage: 'seedSigned'\n        })\n      },\n      onRequestPGPKeyPair: (pgpKeyPairAccount) => {\n        this.setState({\n          stage: 'waitingPGPPairSignature'\n        })\n      },\n      onGeneratedPGPKeyPair: (pgpKey) => {\n        this.setState({\n          stage: 'pgpPairGenerated',\n          pgpKey,\n        })\n      },\n    });\n    try {\n      await keySpace.setUpPGP();\n    } catch (initializationError) {\n      this.setState({\n        stage: 'keyspaceInitializationError',\n        initializationError\n      })\n      return\n    }\n  }\n  renderUnsignedSeed(){\n    const { unsignedSeed } = this.state\n    if(!unsignedSeed) {\n      return null\n    } else {\n      return <AccordianElement label=\"Unsigned Seed\" content={unsignedSeed} />\n    }\n  }\n  renderSignedSeed(){\n    const { signedSeed } = this.state\n    if(!signedSeed) {\n      return null\n    } else {\n      return <AccordianElement label=\"Signed Seed (PGP key encryption password)\" content={signedSeed} />\n    }\n  }\n  renderPGPKey(){\n    const { pgpKey } = this.state\n    if(!pgpKey) {\n      return null\n    } else {\n      return <>\n        <AccordianElement label=\"PGP Public Key\" content={ pgpKey.public\n          .split('\\\\r\\\\n')\n          .map((item, key) => {\n            return <span key={key}>{item}<br/></span>\n          })\n        } />\n        <AccordianElement label=\"PGP Private Key\" content={ pgpKey.private\n          .split('\\\\r\\\\n')\n          .map((item, key) => {\n            return <span key={key}>{item}<br/></span>\n          })\n        } />\n      </>\n    }\n  }\n  render() {\n    const { stage, initializationError, walletAddress } = this.state\n    let content = null\n    let headerContent = null\n    if(stage === 'initial') {\n      content = <Box direction=\"row\">\n        <AuthButton margin=\"small\" onClick={() => this.init('newWallet')} label=\"Generate Temporary Wallet\" />\n\n        <AuthButton margin=\"small\" onClick={() => this.init('metamask')} label=\"Connect To Metamask\" />\n      </Box>\n    }\n    if (stage === 'web3Enabled') {\n      content = <Text>Initializing KeySpace</Text>\n    }\n    if (stage === 'waitingForSeedSignature') {\n      content = <Text>Initializing KeySpace, Sign to create your seed</Text>\n    }\n    if (stage === 'waitingPGPPairSignature') {\n      content = <Text>Sign your generated PGP key pair to authenticate it</Text>\n    }\n    if (stage === 'pgpPairGenerated' && !mobile()) {\n      headerContent = <DropButton\n        label=\"KeySpace is ready\"\n        dropAlign={{ top: 'bottom', right: 'right' }}\n        dropContent={\n          <Box pad=\"medium\" margin=\"medium\" border={{\n            \"color\": \"brand\",\n            \"size\": \"small\",\n            \"side\": \"all\"\n          }}>\n            <Box>\n              <Text size=\"large\">KeySpace Parameters</Text>\n            </Box>\n            { this.renderUnsignedSeed() }\n            { this.renderSignedSeed() }\n            { this.renderPGPKey() }\n          </Box>\n        }\n      />\n    }\n    if(stage === 'keyspaceInitializationError') {\n      content = <Box>\n          <Text>{`Keyspace Initialization Error: ${formatErrorMessage(initializationError)}`}</Text>\n          <AuthButton onClick={() => this.init()} label=\"Retry\" />\n        </Box>\n    }\n    return <Box>\n        <Box pad=\"large\" direction=\"row\" alignContent=\"stretch\" border={{\n          \"color\": \"brand\",\n          \"size\": \"small\",\n          \"side\": \"bottom\"\n        }}>\n          <Box flex={{ grow: 1 }} direction=\"row\">\n            <Text size={ mobile() ? 'medium' :  'xlarge' }>KeySpace Devcon5 Demo</Text>\n          </Box>\n          <HeaderRightBox pad={{ right: 'large' }} direction=\"row\">\n            {\n              headerContent\n            }\n            <AboutButton margin=\"small\" onClick={() => window.open('https://github.com/airswap/keyspace-devcon', '_blank')} label=\"?\" />\n          </HeaderRightBox>\n        </Box>\n        <Container direction=\"row\" fill=\"horizontal\" pad=\"medium\">\n        <Box width=\"100%\">\n          {\n            stage === 'pgpPairGenerated' ?\n              <Messenger address={walletAddress} keySpace={keySpace} /> :\n              <Box align=\"center\">\n                <Box margin=\"medium\">\n                  <Text>Connect a wallet and initialize Keyspace to use the IPFS pubsub chat.</Text>\n                </Box>\n                <Box margin=\"medium\">\n                  { content }\n                </Box>\n              </Box>\n          }\n        </Box>\n      </Container>\n    </Box>;\n  }\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Grommet } from \"grommet\";\n// import Messenger from \"./components/Messenger\";\nimport KeyspaceFlow from \"./components/KeyspaceFlow\";\n// window.setInterval(() => {\n//   debugger;\n//   broadcaster.sendMessage(\"hello ya\");\n// }, 1000);\n\nconst myTheme = {\n  global: {\n    font: {\n      family: \"Lato\"\n    }\n  }\n};\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Grommet full={true} theme={myTheme}>\n        <KeyspaceFlow />\n      </Grommet>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n","const SLS_PGP_URL = \"https://pgp.development.airswap.io\";\n\nmodule.exports = { SLS_PGP_URL }\n","const _ = require('lodash')\n\nfunction formatErrorMessage(error) {\n  if (_.isObject(error) && error.message) {\n    return error.message.split('\\n')[0] // sometimes metamask returns stacktraces and this removes them\n  } else if (_.isString(error)) {\n    return error\n  }\n  return ''\n}\n\nfunction storeSignedSeedForAddress({ address, signedSeed }) {\n  const obj = JSON.stringify({ address, signedSeed })\n  localStorage.setItem('signedSeed', obj)\n}\n\nfunction getSignedSeedForAddress(address) {\n  const signedSeedObj = localStorage.getItem('signedSeed')\n  if(signedSeedObj) {\n    const parsedObj = JSON.parse(signedSeedObj)\n    if(parsedObj.address === address) {\n      return parsedObj.signedSeed\n    }\n  }\n  return undefined\n}\n\nmodule.exports = { formatErrorMessage, storeSignedSeedForAddress, getSignedSeedForAddress }\n","import _ from \"lodash\"\nimport axios from \"axios\"\nimport IPFS from \"ipfs-mini\"\nimport { SLS_PGP_URL } from \"../constants\"\n\n\nconst ipfsInfura = new IPFS({\n  host: \"ipfs.infura.io\",\n  port: 5001,\n  protocol: \"https\"\n});\n\nconst ipfsAirSwap = new IPFS({\n  host: \"ipfs.airswap.io\",\n  port: 443,\n  protocol: \"https\"\n});\n\nconst pinJSONToIPFSPinata = JSONBody => {\n  const url = `${SLS_PGP_URL}/storePinata`;\n  return axios.post(url, JSONBody).then(resp => resp.data.IpfsHash);\n};\n\nexport async function ipfsStoreJSON(obj) {\n  const storeString = _.isString(obj)\n    ? JSON.stringify(JSON.parse(obj))\n    : JSON.stringify(obj);\n\n  return new Promise((resolve, reject) => {\n    // this \"resolved\" syntax is required since there isn't a Promise.none()\n    let resolved = 0;\n    ipfsAirSwap\n      .add(storeString)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 2) {\n          reject(e);\n        }\n      });\n    ipfsInfura\n      .add(storeString)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 2) {\n          reject(e);\n        }\n      });\n\n    pinJSONToIPFSPinata(JSON.parse(storeString)); // pinata will always take the longest to resolve since they don't support reads\n  });\n}\n\nconst fetchIPFSContentFromCloudfare = cid =>\n  axios\n    .get(`https://cloudflare-ipfs.com/ipfs/${cid}`)\n    .then(resp => JSON.stringify(resp.data));\n\nexport async function ipfsFetchJSONFromCID(cid) {\n  const content = await new Promise((resolve, reject) => {\n    if (!cid) {\n      resolve(undefined);\n      return;\n    }\n    // this \"resolved\" syntax is required since there isn't a Promise.none()\n    let resolved = 0;\n    ipfsAirSwap\n      .cat(cid)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 3) {\n          reject(e);\n        }\n      });\n    ipfsInfura\n      .cat(cid)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 3) {\n          reject(e);\n        }\n      });\n\n    fetchIPFSContentFromCloudfare(cid)\n      .then(resolve)\n      .catch(e => {\n        resolved++;\n        if (resolved === 3) {\n          reject(e);\n        }\n      });\n  });\n  return JSON.parse(content);\n}\n"],"sourceRoot":""}